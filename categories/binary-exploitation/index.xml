<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>binary exploitation on Zet’s playground</title>
    <link>https://blog.zet.tw/categories/binary-exploitation/</link>
    <description>Recent content in binary exploitation on Zet’s playground</description>
    <image>
      <url>https://blog.zet.tw/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://blog.zet.tw/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 31 May 2016 00:00:00 +0800</lastBuildDate><atom:link href="https://blog.zet.tw/categories/binary-exploitation/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Return Oriented Programming</title>
      <link>https://blog.zet.tw/posts/2016-05-31-rop/</link>
      <pubDate>Tue, 31 May 2016 00:00:00 +0800</pubDate>
      
      <guid>https://blog.zet.tw/posts/2016-05-31-rop/</guid>
      <description>整理一下
找 getgads 工具  rp++ ROPgadget  Ret2libc 當程式有打開NX的時候造成 stack 上的 shellcode 無法執行，可以利用ret2libc或是利用ROP做mprotect開一個rwx的段，
參數傳遞  x86 利用stack x86_64 利用reg  Ret2libc 疊法 可以盡可能的把參數疊完整，比較不會發生一些鳥問題
一般x86的疊法是：
padding + function + ret address + argv1 + argv2 + argv3 .... 一般 function 可以直接跳 .plt ， ret address 是執行完以後我要去的地方，假如一般疊出 system(&amp;quot;/bin/sh&amp;quot;)，ret address 可以直接填空沒關係
例如 :
&amp;#39;A&amp;#39;*100 + p32(system_addr) + p32(0) + p32(binsh_addr) x64: 利用一些 pop reg 的getgads把reg設定好
x32 參數直接疊在stack上，用 pop_ret 清掉用過的參數
read @ plt pop_pop_pop_ret 0 addr length system @ plt x86_64  最大地址 0x00007fffffffffff  DynELF 假如在不知道對方libc 的情況下可以使用pwntools中的一個工具DynELF，給他一個leak的點，可以幫你找出function的位置</description>
    </item>
    
  </channel>
</rss>
